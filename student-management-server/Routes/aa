const Student = require('../model/student_model');
const StudentToken = require('../../student/model/student_token_model');

const {
    sendEmail
} = require('../../../util/app_helper');

// @route POST api/auth/student/register
// @desc Student Register
exports.register = async (req, res) => {
    try {
        const {
            email
        } = req.body;

        const student = await Student.findOne({
            email
        });

        if (student) return res.status(401).json({
            message: 'The email adress you have entered is already associated with another account'
        });

        const newStudent = new Student({
            ...req.body,
            role: "basic",
        });

        const student_ = await newStudent.save();
        await sendVerificationEmail(student_, req, res);

    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        })
    }
};

// @route POST api/auth/student/login
// @desc Student Login
exports.login = async (req, res) => {
    try {
        const {
            email,
            password
        } = req.body;

        const student = await Student.findOne({
            email
        });

        if (!student) return res.status(401).json({
            message: 'The email adress ' + email + ' is not associated with any account.'
        });

        if (!student.comparePassword(password)) {
            return res.status(401).json({
                message: 'Current password does not match'
            });
        }

        if (!student.isVerified) return res.status(401).json({
            type: 'not-verified',
            message: 'Your account has not been verified'
        });

        res.status(200).json({
            token: student.generateJWT(),
            user: student
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        });
    }
};

// @route GET api/auth/student/verify/student/:token
// @desc Verify token
exports.verify = async (req, res) => {
    if (!req.params.token) return res.status(400).json({
        message: "We were unable to find this student for this token"
    });

    try {
        const token = await StudentToken.findOne({
            token: req.params.token
        });

        if (!token) return res.status(400).json({
            message: 'We were unable to find a valid token. Your token my have expired'
        });

        const student = await Student.findById(token.studentId);

        if (!student) return res.status(400).json({
            message: 'We were unable to find a student'
        });

        student.isVerified = true;
        await student.save();

        if (student.isVerified) return res.status(200).render('verify', {
            message: 'Student successfully verified!'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route POST api/auth/student/resend
// @desc Resend Verification Token
exports.resendToken = async (req, res) => {
    try {
        const {
            email
        } = req.body;

        const student = await Student.findOne({
            email
        });

        if (!student) return res.status(401).json({
            message: 'The email adress ' + req.body.email + ' is not associated with any account'
        });

        if (student.isVerified) return res.status(400).json({
            message: 'This account has already been verified. Please log in'
        });

        await sendVerificationEmail(student, req, res);

    } catch (error) {
        res.status(500).json({
            message: error.message
        });
    }
}

async function sendVerificationEmail(student, req, res) {
    try {
        const studentToken = student.generateVerificationToken();
        await studentToken.save();

        let to = student.email;
        let from = process.env.FROM_EMAIL;
        let replyTo = process.env.FROM_EMAIL;
        let support = process.env.FROM_EMAIL;
        let fullName = student.fullName;

        await sendEmail({
            to,
            from,
            replyTo,
            templateId: process.env.VERIFY_EMAIL_TEMPLATEID,
            dynamicTemplateData: {
                subject: "Account Verification",
                fullname: fullName,
                verifyUrl: "https://" + req.headers.host + "/api/auth/student/verify/student/" + studentToken.token,
                contactUrl: "mailto:" + support,
            },
        });

        res.status(200).json({
            message: 'A verification email has been sent to ' + student.email + '. If you dont receive email, please check your spam or bulk mail folder just in case.'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        });
    }
}


exports.changePassword = async (req, res) => {
    try {
        const id = req.params.id;
        const password = req.body.password;
        const student = await Student.findById(id);

        if (student.comparePassword(password)) {
            return res.status(401).json({
                message: 'Your password is the same as your previous password'
            });
        }

        student.password = password;
        await student.save();

        return res.status(200).json({
            message: 'Password has been updated'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};


//pass controller
const Student = require('../model/student_model');
const {
    sendEmail
} = require('../../../util/app_helper');

// @route POST api/auth/student/recover
// @desc Recover Password
// @access Public
exports.recover = async (req, res) => {
    try {
        const {
            email
        } = req.body;

        const student = await Student.findOne({
            email
        });

        if (!student) return res.status(401).json({
            message: 'The email address ' + req.body.email + ' is not associated with any account. Double-check your email address and try again.'
        });

        await student.generatePasswordReset();
        await student.save();

        let fullName = student.fullName;
        let to = student.email;
        let from = process.env.FROM_EMAIL;
        let support = process.env.SUPPORT_EMAIL;

        await sendEmail({
            to,
            from,
            templateId: process.env.RESET_PASSWORD_TEMPLATEID,
            dynamicTemplateData: {
                fullname: fullName,
                subject: "Password Change Request",
                contact_url: "mailto:" + support,
                otpCode: student.resetPasswordOTP
            }
        });

        res.status(200).json({
            message: 'A reset email has been sent to ' + student.email + '.'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route POST api/auth/student/reset
// @desc Reset Password 
// @access Public
exports.reset = async (req, res) => {
    try {
        const {
            otpCode
        } = req.body;

        const student = await Student.findOne({
            resetPasswordOTP: otpCode,
            resetPasswordExpires: {
                $gt: Date.now()
            }
        });

        if (!student) return res.status(401).json({
            message: 'Password reset token is invalid or has expired.'
        });

        res.status(200).json({
            message: 'You are successfully redirected to the password change screen',
            otpCode: student.otpCode
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route POST api/auth/student/reset/:otpCode
// @desc Reset Password Otp Code
// @access Public
exports.resetPassword = async (req, res) => {
    try {
        let otpCode = req.params.otpCode;
        const student = await Student.findOne({
            resetPasswordOTP: otpCode,
            resetPasswordExpires: {
                $gt: Date.now()
            }
        });

        if (!student) return res.status(401).json({
            message: 'Password reset otp is invalid or has expired'
        });

        student.password = req.body.password;
        student.resetPasswordExpires = undefined;
        student.resetPasswordOTP = undefined;

        await student.save();

        res.status(200).json({
            message: 'Your password has been updated'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

const Teacher = require('../model/teacher_model');

// @route POST api/teacher/changepassword/:id
// @desc Teacher Change Password
exports.changePassword = async (req, res) => {
    try {
        const id = req.params.id;
        const password = req.body.password;
        const teacher = await Teacher.findById(id);

        if (teacher.comparePassword(password)) {
            return res.status(401).json({
                message: 'Your password is the same as your previous password'
            });
        }

        teacher.password = password;
        await teacher.save();

        return res.status(200).json({
            message: 'Password has been updated'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route POST api/teacher/update/:id
// @desc Teacher Update
exports.update = async function (req, res) {
    try {
        const id = req.params.id;
        const newName = req.body.fullName;

        const teacher = await Teacher.findById(id);

        if (!teacher) return res.status(401).json({
            message: 'Teacher does not exist'
        });

        if (newName == teacher.fullName) return res.status(401).json({
            message: 'Same as previous name!'
        });

        teacher.fullName = newName;

        await teacher.save();

        res.status(200).json({
            message: 'Name successfully updated'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        });
    }
};

const Course = require('./model/course_model');
const Student = require('../student/model/student_model');
const AWS = require('aws-sdk');

// @route POST api/student/course/joincourse
// @desc Join course with courseCode
// @access Public
exports.joinCourse = async (req, res) => {
    try {
        const courseCode = req.body.courseCode;
        const id = req.body.studentId;
        const student = await Student.findById(id);
        const course = await Course.findOne({
            'courseCode': courseCode
        });

        if (!course) return res.status(401).json({
            message: 'Course does not exist'
        });

        const attendanceArray = course.attendance;
        const studentAlreadyIn = await course.students.find((s) => s.id === id);

        for (let i = 0; i < attendanceArray.length; i++) {
            var studentInAttendanceArray = await attendanceArray[i].students.find((student) => student.id === id);
        }

        if (studentAlreadyIn || studentInAttendanceArray) {
            return res.status(401).json({
                message: 'You have already enrolled this course'
            });
        }

        await course.students.push(student);

        for (let i = 0; i < attendanceArray.length; i++) {
            attendanceArray[i].students.push(student);
        }

        await course.save();

        res.status(200).json({
            course,
            message: 'Successfully joined the course'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route DELETE api/student/course/leave/:id
// @desc Leave course
// @access Public
exports.leaveCourse = async function (req, res) {
    try {
        const id = req.params.id;
        const courseId = req.body.courseId;

        const course = await Course.findById(courseId);
        const student = await course.students.find((s) => s.id == id);

        await student.remove();

        const attendanceArray = course.attendance;

        for (let i = 0; i < attendanceArray.length; i++) {
            var studentInAttendanceArray = await attendanceArray[i].students.find((student) => student.id == id);
            await studentInAttendanceArray.remove();
        }

        await course.save();

        res.status(200).json({
            message: 'Successfully leaved'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        });
    }
};

// @route GET api/student/course/:id
// @desc Show one course 
// @access Public
exports.showOneCourse = async function (req, res) {
    try {
        const id = req.params.id;
        const studentId = req.body.studentId;
        const course = await Course.findById(id);

        if (!course) return res.status(401).json({
            message: 'Course does not exist'
        });

        const attendanceArray = course.attendance;
        let studentAttendanceArray = [];

        for (let i = 0; i < attendanceArray.length; i++) {
            studentAttendanceArray[i] = {};
            let studentInAttendance = await attendanceArray[i].students.find((student) => student.id == studentId);
            studentAttendanceArray[i].date = attendanceArray[i].date;
            studentAttendanceArray[i].time = attendanceArray[i].time;
            studentAttendanceArray[i].attendanceStatus = studentInAttendance.attendanceStatus;
        }

        res.status(200).json({
            teacher: course.teacher.fullName,
            courseShortName: course.courseShortName,
            courseName: course.courseName,
            courseCode: course.courseCode,
            students: course.students,
            attendance: studentAttendanceArray
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route GET api/student/course/list/:id
// @desc Show course list
// @access Public
exports.showCourseList = async function (req, res) {
    try {
        const studentId = req.params.id;

        let courseList = await Course.find({
            "students._id": studentId
        }).exec();

        if (!courseList) return res.status(401).json({
            message: 'Course list does not exist'
        });

        res.status(200).json({
            courseList
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

const Course = require('./model/course_model');
const Student = require('../student/model/student_model');
const Teacher = require('../teacher/model/teacher_model');
const moment = require('moment');
const fs = require('fs-extra');

const AWS = require('aws-sdk');
const s3 = new AWS.S3({
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    region: process.env.AWS_REGION,
});


const config = new AWS.Config({
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    region: process.env.AWS_REGION,

});
const rekognition = new AWS.Rekognition();

// @route POST api/teacher/course/addcourse
// @desc Add new course
// @access Public
exports.addCourse = async (req, res) => {
    try {
        const id = req.body.teacherId;
        const teacher = await Teacher.findById(id);
        const newCourse = new Course({
            ...req.body,
        });

        await newCourse.generateRandomCourseCode();
        const course_ = await newCourse.save();
        course_.teacher = teacher;

        await course_.save();

        res.status(200).json({
            message: 'Course successfully created'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route DELETE api/teacher/course/deletecourse/:id
// @desc Delete course
// @access Public
exports.deleteCourse = async function (req, res) {
    try {
        const id = req.params.id;
        await Course.findByIdAndDelete(id);

        res.status(200).json({
            message: 'Course has been deleted'
        });
    } catch (error) {
        res.status(500).json({
            message: error.message
        });
    }
};

// @route POST api/teacher/course/addschedule/:id
// @desc Add course schedule
// @access Public
exports.addCourseSchedule = async (req, res) => {
    try {
        const id = req.params.id;
        let courseStartDate = req.body.courseStartDate; //20.10.2021
        let courseEndDate = req.body.courseEndDate; //20.10.2021
        let courseTime = req.body.courseTime; //09:00-12:00
        const currentCourse = await Course.findById(id);

        if (!currentCourse) res.status(401).json({
            message: 'Course does not exist'
        });

        let courseScheduleArray = [];
        let timeArray = [];
        let dateArray = [];

        let startDate = moment(courseStartDate, 'DD-MM-YYYY');
        let endDate = moment(courseEndDate, 'DD-MM-YYYY');

        while (startDate <= endDate) {
            dateArray.push(moment(startDate).format('DD-MM-YYYY'));
            timeArray.push(courseTime);
            startDate = moment(startDate).add(7, 'days');
        }

        for (let i = 0; i < dateArray.length; i++) {
            courseScheduleArray[i] = {};
            courseScheduleArray[i].date = dateArray[i];
            courseScheduleArray[i].time = timeArray[i];
        }

        currentCourse.attendance = courseScheduleArray;
        await currentCourse.save();

        res.status(200).json({
            message: 'Course schedule successfully added'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};
// @route GET api/teacher/course/:id
// @desc Get one course
// @access Public
exports.showOneCourse = async function (req, res) {
    try {
        const id = req.params.id;
        const course = await Course.findById(id);

        if (!course) return res.status(401).json({
            message: 'Course does not exist'
        });

        res.status(200).json({
            course
        });
    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route GET api/teacher/course/list/:id
// @desc Get course list
// @access Public
exports.showCourseList = async function (req, res) {
    try {
        const teacherId = req.params.id;
        let courseList = await Course.find({
            "teacher._id": teacherId
        }).exec();

        if (!courseList) return res.status(401).json({
            message: 'Course list does not exist'
        });

        res.status(200).json({
            courseList
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route POST api/teacher/course/takeattendance/:id/:date
// @desc Check course attendance
// @access Public
exports.takeAttendance = async (req, res) => {
    try {
        const id = req.params.id;
        const date = req.params.date;
        const currentCourse = await Course.findById(id).exec();

        if (!currentCourse) res.status(401).json({
            message: 'Course does not exist'
        });

        var image = req.file;

        if (!image) res.status(401).json({
            message: 'You must upload at least one image'
        });

        const imageData = await s3.getObject({
            Bucket: "attendancesystembucket",
            Key: req.file.originalname,
        }).promise();

        await fs.writeFile('./uploads/' + imageData.originalname, imageData.Body);

        const imageRead = await fs.readFileSync('./uploads/' + imageData.originalname);
        var imageByte = Buffer.from(imageRead.toString('base64'), 'base64');
        let currentAttendance = await currentCourse.attendance.find((attendance) => attendance.date == date);

        if (!currentAttendance) res.status(401).json({
            message: 'No attendance record available by this date'
        });

        let studentsArray = currentAttendance.students;
        let participateStudent = 0;

        for (let i = 0; i < studentsArray.length; i++) {
            var studentId = studentsArray[i].id;
            var student = await Student.findById(studentId);
            var studentImageByte = student.studentImage.imageByte;
            var faceData = await rekognition.compareFaces({
                SimilarityThreshold: 70,
                TargetImage: {
                    Bytes: imageByte
                },
                SourceImage: {
                    Bytes: studentImageByte
                }
            }).promise();

            if (faceData.FaceMatches.length > 0) {
                studentsArray[i].attendanceStatus = true;
                participateStudent++;
            }
            await currentCourse.save();
        }

        return res.status(200).json({
            message: 'Attendance successfully taken'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};
// @route GET api/teacher/course/showattendance/:id/:date
// @desc Check course attendance
// @access Public
exports.showAttendance = async (req, res) => {
    try {
        const id = req.params.id;
        const date = req.params.date;

        const currentCourse = await Course.findById(id);

        if (!currentCourse) res.status(401).json({
            message: 'Course does not exist'
        });

        let currentAttendance = await currentCourse.attendance.find((attendance) => attendance.date == date);

        if (!currentAttendance) res.status(401).json({
            message: 'No attendance record available by this date'
        });

        let studentsArray = currentAttendance.students;
        let participateStudent = 0;
        let absentStudent = 0;

        for (let i = 0; i < studentsArray.length; i++) {
            if (studentsArray[i].attendanceStatus == true) {
                participateStudent++;
            }
            if (studentsArray[i].attendanceStatus == false) {
                absentStudent++;
            }
        }

        res.status(200).json({
            totalStudent: studentsArray.length.toString(),
            participateStudent: participateStudent.toString(),
            absentStudent: absentStudent.toString(),
            studentsArray: studentsArray,
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};
// @route POST api/teacher/course/manageattendance/:id/:date
// @desc Update course attendance
// @access Public
exports.manageAttendance = async (req, res) => {
    try {
        const id = req.params.id;
        const date = req.params.date;
        let statusArray = req.body.statusArray;

        const currentCourse = await Course.findById(id);

        if (!currentCourse) res.status(401).json({
            message: 'Course does not exist'
        });

        let currentAttendance = await currentCourse.attendance.find((attendance) => attendance.date == date);

        if (!currentAttendance) res.status(401).json({
            message: 'No attendance record available by this date'
        });

        let studentsArray = currentAttendance.students;
        let participateStudent = 0;

        for (let i = 0; i < studentsArray.length; i++) {
            if (statusArray[i] == "true") {
                studentsArray[i].attendanceStatus = true;
                participateStudent++;
            } else {
                studentsArray[i].attendanceStatus = false;
            }
            await currentCourse.save();
        }

        res.status(200).json({
            totalStudent: studentsArray.length.toString(),
            participateStudent: participateStudent.toString(),
            absentStudent: (studentsArray.length - participateStudent).toString(),
            studentsArray: studentsArray,
            message: 'Attendance for the course was successfully updated'
        });

    } catch (error) {
        res.status(500).json({
            message: error.message
        })
    }
};

// @route POST api/teacher/course/update/:id
// @desc Course Update
exports.update = async function (req, res) {
    try {
        const id = req.params.id;
        const newCourseName = req.body.courseName;
        const newCourseShortName = req.body.courseShortName;

        const course = await Course.findById(id);

        if (!course) return res.status(401).json({
            message: 'Course does not exist'
        });

        if (!newCourseShortName) {
            //Course Name
            if (newCourseName == course.courseName) return res.status(401).json({
                message: 'Same as previous course name!'
            });

            course.courseName = courseName;

            await course.save();

            res.status(200).json({
                message: 'Course name successfully updated'
            });

        } else {
            //Course Short Name
            if (!newCourseName) {
                if (newCourseShortName == course.courseShortName) return res.status(401).json({
                    message: 'Same as previous course short name!'
                });

                course.courseShortName = newCourseShortName;
                await course.save();

                res.status(200).json({
                    message: 'Course short name successfully updated'
                });

            } else {
                if (newCourseName === course.courseName) {
                    course.courseShortName = newCourseShortName;
                    await course.save();
                    res.status(200).json({
                        message: 'Course short name successfully updated'
                    });

                } else {
                    //Course Name and Short Name
                    course.courseName = newCourseName;
                    course.courseShortName = newCourseShortName;
                    await course.save();

                    res.status(200).json({
                        message: 'Course information successfully updated'
                    });
                }
            }
        }
    } catch (error) {
        res.status(500).json({
            message: error.message
        });
    }
};

const mongoose = require('mongoose');
const {
    generateCourseCode
} = require('../../../util/app_helper');

const CourseSchema = mongoose.Schema({
    courseCode: {
        type: String,
        required: true,
        unique: true
    },
    courseShortName: {
        type: String,
        required: true
    },
    courseName: {
        type: String,
        required: true
    },
    teacher: {
        _id: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Teacher'
        },
        fullName: {
            type: String,
            ref: 'Teacher'
        },
        email: {
            type: String,
            ref: 'Teacher'
        },
    },
    students: [{
        stdId: {
            type: String,
            ref: 'Student'
        },
        email: {
            type: String,
            ref: 'Student'
        },
        fullName: {
            type: String,
            ref: 'Student'
        },
        imageUrl: {
            type: String,
            ref: 'Student'
        },
        studentImage: {
            imageByte: {
                type: Buffer,
                ref: 'Student'
            },
            fileType: {
                type: String,
                ref: 'Student'
            },
        },

    }],
    attendance: [{
        date: {
            type: String,
            default: '0'
        },
        time: {
            type: String,
            default: '0'
        },
        students: [{
            stdId: {
                type: String,
                ref: 'Student'
            },
            email: {
                type: String,
                ref: 'Student'
            },
            fullName: {
                type: String,
                ref: 'Student'
            },
            attendanceStatus: {
                type: Boolean,
                default: false
            },
        }],
    }],
}, {
    timestamps: true,
    versionKey: false
});

CourseSchema.methods.generateRandomCourseCode = function () {
    this.courseCode = generateCourseCode();
};

module.exports = mongoose.model('Course', CourseSchema);